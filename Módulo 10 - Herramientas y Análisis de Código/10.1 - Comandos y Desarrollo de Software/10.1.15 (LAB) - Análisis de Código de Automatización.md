# 10.1.15 - Práctica de Laboratorio: Análisis de Código de Automatización
#### Tarea de soluciones de seguridad de Protego
El análisis de vulnerabilidades y la recopilación de información pueden llevar mucho tiempo. Como ha visto, hay varios productos de software disponibles que automatizan estos procesos mediante el uso de varias herramientas contra varios objetivos. Si bien los escáneres automatizados son excelentes y pueden hacer mucho por nosotros, a veces no satisfacen nuestras necesidades específicas.<br>
Es importante que mejore sus habilidades de codificación para poder comprender los guiones de automatización escritos en una variedad de lenguajes de guiones. Debe comprender los guiones existentes y poder modificarlos para satisfacer nuestras necesidades actuales. Tenemos nuestro propio repositorio de scripts de automatización que hemos desarrollado y que utilizamos con frecuencia en Protego. También debe tener conocimientos suficientes de secuencias de comandos para crear algunas de sus propias secuencias de comandos siguiendo ejemplos y consultando recursos en línea y foros de codificación.<br>

## Objetivos
En esta práctica de laboratorio se cumplirán los siguientes objetivos:<br>
+ Parte 1: Escribir un script de Bash para automatizar un escaneo de Nmap y almacenar los resultados.
+ Parte 2: Diferenciar entre scripts escritos en Bash, Python, Ruby y Powershell.<br>

## Trasfondo / Escenario
Las pruebas de penetración a menudo requieren tareas repetitivas que utilizan varias herramientas para realizar el reconocimiento, el análisis y el aprovechamiento de los sistemas vulnerables. La creación de scripts para automatizar estas tareas reduce el tiempo necesario para completar el proyecto de pruebas de penetración.<br>

## Recursos necesarios
+ Máquina Virtual Kali Linux

## Parte 1: Escriba un script de Bash para automatizar un escaneo de Nmap y almacenar los resultados

### Paso 1: Cree un script básico de Bash
El shell de Bash tiene un intérprete de scripts incorporado. Los scripts de bash se pueden escribir en cualquier editor de texto y requieren una experiencia mínima en programación. Los scripts se pueden ejecutar desde el indicador de shell de Bash. La sintaxis y la estructura de los scripts de Bash son similares a las que escribiría en la línea de comandos si realizara la tarea manualmente. En este paso, escribirá un breve script denominado `recon.sh` para realizar un escaneo simple de Nmap.<br>
+ Para comenzar su primer script, inicie sesión en Kali. Abra una ventana de terminal y haga ping al host de destino en 10.6.6.23 para asegurarse de que esté disponible en la red.<br>

    ```bash
    ┌──(kali㉿Kali)-[~]
    └─$ ping -c5 10.6.6.23
    PING 10.6.6.23 (10.6.6.23) 56(84) bytes of data.
    64 bytes from 10.6.6.23: icmp_seq=1 ttl=64 time=0.229 ms
    64 bytes from 10.6.6.23: icmp_seq=2 ttl=64 time=0.048 ms
    64 bytes from 10.6.6.23: icmp_seq=3 ttl=64 time=0.060 ms
    64 bytes from 10.6.6.23: icmp_seq=4 ttl=64 time=0.054 ms
    64 bytes from 10.6.6.23: icmp_seq=5 ttl=64 time=0.038 ms
 

    --- 10.6.6.23 ping statistics ---
    5 packets transmitted, 5 received, 0% packet loss, time 5451ms
    rtt min/avg/max/mdev = 0.038/0.085/0.229/0.071 ms
    ```
Abra el editor de texto `Mousepad` desde el menú de `Applications`. (Se puede utilizar cualquier editor de texto para crear el archivo). La primera línea del script de Bash es un tipo especial de línea de comentario que indica la ubicación del intérprete que se utilizará para ejecutar el código. Esta línea se denomina "shebang" y es común a la mayoría de los scripts de Linux. Ingrese `#!/bin/bash` en la línea 1, esto identifica el lenguaje del script para el intérprete de comandos.<br>

```bash
    #!/bin/bash                 # 1
```
En este script, el usuario ingresará la dirección IP del destino como una opción de línea de comando. Si no se ingresa ninguna opción, el usuario recibirá un mensaje de error con la sintaxis correcta del comando. Ingrese la secuencia `if/then` como se muestra.<br>
```bash
        # Verificar que se haya ingresado la IP objetivo                        # 2
        if [ -z "$1" ]                                                          # 3
            then                                                                # 4
                echo "El uso correcto es ./recon.sh <IP>"                       # 5
                exit                                                            # 6
            else                                                                # 7
                echo "IP Objetivo $1"                                           # 8
        fi                                                                      # 9
```
Analizar el código del script es una habilidad importante para un evaluador de penetración. No solo escribirá código de automatización, a menudo deberá determinar qué hace un script existente. El significado de cada línea es el siguiente:<br>

+ La línea 2 es una línea de comentario que comienza con un número de etiqueta hash. Las líneas que comienzan con # se utilizan para documentar el script. El intérprete de comandos ignora las líneas de comentario.
+ La línea 3 inicia una prueba para determinar si existe la variable de opción de entrada `$1`. De manera predeterminada, los scripts de Bash aceptan opciones de la línea de comandos en variables numeradas por su posición en el comando. `-z` devuelve "verdadero" si el valor de `$1` es nulo. Bash rquiere un espacio después del primer corchete y un espacio antes del último corchete (`[ -z "$1" ]`).
+ La línea 4 indica qué hacer si la variable de opción no existe (es nula). Las líneas 5 y 6 están indentadas para indicar que forman parte de la cláusula `then`.
+ La línea 5 imprime un mensaje en la pantalla. Bash usa el comando `echo` para imprimir en la pantalla lo que está en las comillas dobles.
+ La línea 6 hará que la ejecución del script se detenga y salga a la CLI si se cumple la condición.
+ La línea 7 indica qué hacer si la condición `if` es falsa.
+ La línea 8 imprime un mensaje con el valor de entrada que se proporcionó y almacenó en la variable `$1`. Tenga en cuenta que se requiere más trabajo para validar que la entrada sea realmente una dirección IP válida. Esto está fuera del alcance de este curso.
+ La línea 9 indica que las cláusulas `if/then` están completas.

+ Guarde su archivo con el nombre `recon.sh`. En este ejemplo, el archivo se guada en el directorio `/home/kali`.
+ Para convertir un archivo de texto en un ejecutable, es necesario cambiar los permisos de Linux en el archivo. Abra una ventana de terminal en el escritorio de Kali. Enumere el directorio con `ls` y verifique el archivo de script esté allí y tenga el nombre correcto. Ingrese el comando `chmod +x` para agregar el permiso ejecutable a su archivo.

    ```bash
    ┌──(kali㉿Kali)-[~]
    └─$ chmod +x recon.sh
    ```
+ Pruebe su script ejecutándolo primero con la dirección IP del destino (`10.6.6.23`) especificada.
    ```bash
    ┌──(kali㉿Kali)-[~]
    └─$ ./recon.sh 10.6.6.23
    Target IP 10.6.6.23
    ```
+ Pruebe su script ejecutándolo de la siguiente manera:<br>
  1. Sin entrada proporcionada después del nombre del script
  2. Con otro texto o una dirección IP no válida después del nombre del script<br>Tenga en cuenta que si ingresa texto no numérico, debe ir entre comillas.<br>
+ El propósito del script es automatizar el escaneo de Nmap usando el valor de la dirección IP de destino que se proporciona al script. <br>Si el valor proporcionado no es una dirección IP legal, causará un error en Nmap y el script fallará.
+ Ahora edite el archivo de secuencia de comandos para ingresar los comando que ejecutarán el análisis de Nmap. Utilice la variable `$1` para indicar la dirección IP del dispositivo de destino que desea escanear. Los resultados del análisis de Nmap se escribirán en nun archivo denominado `scan_results.txt` en el directorio actual.<br>
    ```bash
        echo "Ejecutando Nmap..."                                                               # 8
        # Ejecutar Nmap para escanear el objetivo y guardar los resultados en un archivo        # 9
        nmap -sV $1 > res_escaneo.txt                                                           # 10
        echo "Escaneo completado - resultados escritos en res_escaneo.txt."                     # 11
    ```
+ Con este escaneo, Nmap buscará servicios abiertos y sus números de versión.
+ Guarde el script. A continuación se muestra el script `recon.sh` hasta ahora.
    ```bash
        #!/bin/bash
        # Verificar que se haya ingresado la IP objetivo
        if [ -z "$1" ]
            then
                echo "El uso correcto es ./recon.sh <IP>"
                exit
            else
                echo "IP Objetivo $1"
                echo "Ejecutando Nmap..."
        # Ejecutar escaneo de Nmap al objetivo y guardar los resultados a un archivo
            nmap -sV $1 > res_escaneo.txt
            echo "Escaneo completado - resultados escritos en res_escaneo.txt."
        fi
    ```
+ Vuelva a ejecutarlo con la dirección IP de destino proporcionada.
    ```bash
        ┌──(kali㉿kali)-[~]
        └─$ ./recon.sh 10.6.6.23
        Target IP 10.6.6.23
        Ejecutando Nmap....
        Escaneo completado -- resultados escritos en res_escaneo.txt.
    ```
+ Utilice el comando `cat` para ver el contenido del archivo `res_escaneo.txt` que creó con el script. El resultado muestra los puertos abiertos en el destino.
    ```bash
        21/tcp  open  ftp
        22/tcp  open  ssh
        53/tcp  open  domain
        80/tcp  open  http
        139/tcp open  netbios-ssn
        445/tcp open  microsoft-ds
    ```
### Paso 2: Modifique el script para enumerar los recursos compartidos en el destino
Como se vio en el paso anterior, el destino 10.6.6.23 tiene puertos abiertos que podrían indicar un servidor Samba. En este paso, editará el script para ejecutar `enum4linux` si un puerto de uso compartido de unidad Samba está abierto para determinar los recursos compartidos de unidad o las cuentas de usuario disponibles. Los puertos 139 y 445 abiertos indican que se está ejecutando un servidor Samba en el host.<br>
+ Abra el archivo `recon.sh` en el editor de texto. Agregue los siguientes comandos:<br>
    ```bash
        # Si se encuentra el puerto 445 y está abierto, ejecutar enum4linux                 # 13
        if grep 445 res_escaneo.txt | grep -iq open                                         # 14
        then                                                                                # 15
            enum4linux -U -S $1 >> res_escaneo.txt                                          # 16
            echo "Samba encontrado. Enumeración completada."                                # 17
            echo "Resultados añadidos a res_escaneo.txt."                                   # 18
            echo "Para ver los resultados, ejecute cat seguido del nombre del archivo."     # 19
        else                                                                                # 20
            echo "No se encontraron puertos SMB abiertos."                                  # 21
        fi                                                                                  # 22
    ```
+ Analice el código adicional.
+ La línea 13 es un comentario
+ La línea 14 indica el inicio de una instrucción `if/then` que buscará en los resultados de Nmap el puerto abierto 445. El comando `grep` busca líneas en el archivo que coincidan con el patrón "`445 open`". El comando `grep` busca primero las líneas que coincidan con el patrón "`445`". Luego, la salida se canaliza a un segundo comando `grep` para buscar nuevamente las líneas que coinciden con el patrón `open` (abierto). Con la opción `-i`, el comando `grep` ignora las distinciones entre mayúsculas y minúsculas en los patrones de búsqueda. La opción `-q` suprime las salidas estándar.
+ La línea 15 es la cláusula "`then`". Contiene el comando que se ejecutará si la prueba `if` devuelve "`true`" (verdadero).
+ Las líneas 16 a 19 se ejecutan si se encuentra el puerto de uso compartido de archivos SMB (445). La línea 16 ejecuta `enum4linux` con las opciones `-U` y `-S` en el host de destino especificado en `$1` y agrega los resultados al final de res_escaneo.txt, la opción `-U` enumera los usuarios encontrados y la opción `-S` enumera los recursos compartidos de la unidad. Las líneas 17, 18 y 19 muestran mensajes cuando enum4linux finalizó el análisis y proporciona instrucciones para ver los resultados.
+ La línea 20 indica la acción a realizar si la condición falla.
+ La línea 21 muestra un mensaje si el puerto de uso compartido de archivos SMB (445) no está abierto.
+ En la línea 22, `fi` significa el final de la cláusula `if/then`.
+ Guarde el archivo `recon.sh` en el editor de texto y salga a la línea de comandos. A continuación se muestra el script completo `recon.sh`.
    ```bash
        #!/bin/bash
        # Verificar que se haya ingresado la IP objetivo
        if [ -z "$1" ]
            then
                echo "El uso correcto es ./recon.sh"
                exit
            else
                echo "IP objetivo $1"
                echo "Ejecutando Nmap..."
        # Ejecutar escaneo de Nmap al objetivo y guardar los resultados a un archivo
            nmap -sV $1 > res_escaneo.txt
            echo "Escaneo completado - resultados escritos en res_escaneo.txt."
        fi
        # Si se encuentra el puerto 445 y está abierto, ejecutar enum4linux
        if grep 445 res_escaneo.txt | grep -iq open
            then
                enum4linux -U -S $1 >> res_escaneo.txt
                echo "Samba encontrado. Enumeración completada."
                echo "Resultados añadidos a res_escaneo.txt."
                echo "Para ver los resultados, ejecuta cat seguido del nombre del archivo."
            else
                echo "No se encontraron puertos SMB abiertos."
        fi
    ```
+ Vuelva a ejecutar el script en el sistema de destino (10.6.6.23).
    ```bash
        ┌──(kali㉿kali)-[~]
        └─$ ./recon.sh 10.6.6.23
        Ejecutando Nmap...
        Escaneo completado -- resultados escritos en res_escaneo.txt.
        Samba encontrado. Enumeración completada.
        Resultados añadidos a res_escaneo.txt.
        Para ver los resultados, ejecuta cat seguido del nombre del archivo.
    ```
+ Utilice el comando `cat` para ver los resultados contenidos en el archivo res_escaneo.txt. Se encontraron los siguientes recursos compartidos de archivos en el destino:<br>
    ```bash
                homes           Disk      All home directories
                workfiles       Disk      Confidential Workfiles
                print$          Disk      Printer Drivers
                IPC$            IPC       IPC Service (Samba 4.9.5-Debian)
    ```
### Paso 3: Automatice Nmap desde la línea de comandos
Otra forma de automatizar Nmap es escanear un grupo de objetivos específicos que se especifican en un archivo externo.
+ Cree un nuevo archivo en el Mousepad y escriba las direcciones IP de los hosts existentes en la red 10.6.6.0/24. Para enumerar todos los hosts disponibles con sus direcciones IP, ingrese el comando `containers` en una terminal.<br>Asegúrese de que las direcciones IP estén separadas con un espacio o enumere cada dirección IP en una línea separada.
+ Guarde el archivo con el nombre `to_scan.txt`.
+ En el indicador, ingrese el comando para ejecutar Nmap con los destinos del archivo.<br>Para los fines de esta práctica de laboratorio, solo se ejecutará un análisis de ping simple, pero cualquier tipo de análisis que tome una dirección IP como destino se puede ejecutar de esta manera:<br>
    ```bash
        ┌──(kali㉿Kali)-[~]
        └─$ nmap -sn -iL to_scan.txt
    ```
+ Después de una breve demora, debería ver que Nmap genera los informes de análisis para cada host que se especificó en el archivo `to_scan.txt`.<br>

__Nota:__ el archivo `to_scan.txt` no requiere permisos de ejecución porque sirve como archivo de datos, no como archivo de secuencia de comandos.<br>

### Parte 2: Diferenciar entre scripts escritos en Bash, Python, Ruby y PowerShell
En esta parte, usará lo que aprendió en la parte anterior sobre la escritura y el análisis de un script de Bash para analizar scripts escritos previamente. Saber qué lenguaje de secuencias de comandos se utiliza en las secuencias de comandos que descubre durante las pruebas de penetración le permite comprender el propósito de la secuencia de comandos y, potencialmente, poder modificarla para obtener información adicional.<br>
Utilice este gráfico que ilustra las diferentes características de sintaxis de los lenguajes de secuencias de comandos.<br>

| <h3 style="text-align:center;">Función</h3> | <h3 style="text-align:center;">Python</h3> | <h3 style="text-align:center;">Bash</h3> | <h3 style="text-align:center;">Ruby</h3> | <h3 style="text-align:center;">PowerShell</h3> |
|---------|--------|------|------|---------|
| <br>__Ejemplo de Shebang__: línea de comentario especial en la parte superior del script que identifica la ruta al intérprete<br><br> | _#!/usr/bin/python3_ | _#!/bin/bash_ | _#!/usr/local/bin/ruby_ | _#!/usr/bin/env pwsh_<br><br>Solo es necesario si se ejecuta PS en Linux, no es necesario en Windows | 
| Carga de módulos |<br>import _libraryName_ as _alias_<br>from _libraryName_ import _subModule_<br><br> | n/a; Bash no requiere cargar módulos | <br>Requiere _'libraryName'_<br><br>Las bibliotecas autónomas se denominan 'gemas'<br><br> | n/a; PowerShell no requiere cargar módulos |
| Definición de variables | _variableName_ = _variableValue_ | <br>_variableName_ = _variableValue_<br><br>A las variables leídas como opciones desde la CLI se les asignan $1, $2, ..., $n<br><br> | variableName = variableValue<br><br>No puede comenzar con un número o una letra mayúscula. | _$varvariableName = varvariableValue_ |
| Variables de llamada | _variableName_<br><br>Ejemplo:<br>print(_variableName_) | _\$variableName_<br><br>Ejemplo:<br>echo _$variableName_ | _#variableName_<br><br>Ejemplo:<br>puts _variableName_ | <br>_\$variableName_<br><br>Ejemplo:<br>PS C:\\> _$variableName_<br><br> |
| Comparación | <br>Utiliza símbolos aritméticos<br><br>__Igual:__ `==`<br>__No es igual:__ `!=`<br>__Mayor que:__ `>`<br>__Igual o mayor que:__ `>=`<br>__Menor que:__ `<`<br>__Igual o menor que:__ `<=`.<br><br> | <br>Usos alfa:<br><br>__Igual a:__ `-eq`<br>__No igual a:__ `-ne`<br>__Mayor que:__ `-gt`<br>__Mayor o igual a:__ `-ge`<br>__Menor que:__ `-lt`<br>__Menor o igual que:__`-le`<br><br>Ejemplo:<br>`$x -gt 8`<br><br>Si utiliza símbolos aritméticos, escríbalos entre paréntesis dobles.<br>`(($a > $b))`<br><br> | Utiliza símbolos aritméticos<br><br>__Igual es:__ `==`<br>__No es igual:__ `!=`<br>__Mayor que:__ `>`<br>__Igual o mayor que:__ `>=` __Menor que:__ `<`<br>__Igual o menor que:__ `<=` | Utiliza una variedad de operadores:<br><br>__Igual a:__ `-eq`, `-ieq`, `-ceq`<br>__No igual a:__`-ne`, `-ine`, `-cne`<br>__Mayor que:__ `-gt`, `-igt`, `-cgt`<br>__Mayor o igual que:__ `-ge`, `-ige`, `-cge`<br>__Menor que:__ `-lt`, `-ilt`, `-clt`<br>__Menor o igual que:__ `-le`, `-ile`, `-cle`<br> | 
| Condiciones If | __if__ _condición1:_<br>_acción1_<br>__elif__ _condición2:_<br>_acción2_<br>__else:__<br>_acción3_ | __if [condición1]__<br>__then__ _acción1_<br>__elif [condición2]__<br>__then__ _acción2_<br>__else__<br>_acción3_<br>__fi__<br> | <br>__if__ _condición1_<br>_acción1_<br>__elsif__ _condición2_<br>_acción2_<br>__else__<br>_acción3_<br>__end__<br>__unless__ se puede usar si solo se marca si una condición es "not true" | <br>__if__ (_condición1_) {<br> _acción1_<br> }<br>__elseif__ (_condición2_) {<br>_action2_ }<br>__else__ {<br> _acción3_ <br>} | 
| Bucles Do While | <br>Ejemplo:<br>i = 1<br>while i < 6:<br>print(i)<br>i = I + 1<br>print("All done")<br><br> | <br>Ejemplo:<br>x=1<br>while [ $x -le 5 ]<br>do<br>echo "count " $x<br>x=$(( $x + 1 ))<br>done<br><br> | <br>Ejemplo:<br>while x >= 1<br>puts #@x<br>x = X - 1<br>end<br><br> | <br>Ejemplo:<br>do {<br>Write-Host $x<br>$x =$ x-- } while ($x -ge 1) |

+ Revise el ejemplo de código que se muestra. Utilice las características de sintaxis para determinar qué lenguaje de secuencias de comandos se utiliza para interpretar el código.<br>

    ```Python
        1  import nmap
        2  # take the range of ports to
        3  # be scanned
        4  begin = 21
        5  end = 80
        6 target = '10.6.6.23'
        7  # scan the port range
        8  for i in range(begin,end+1):
        9   results = nmap.PortScanner(target,str(i))
        10  results = results['scan'][target]['tcp'][i]['state']
        11  print('Port {i} is {results}.')
    ```
+ Revise el ejemplo de código que se muestra. Utilice las características de sintaxis para determinar qué lenguaje de secuencias de comandos se utiliza para interpretar el código.<br>
    ```bash
        1  require 'nmap/command'
        2  Nmap::Command.sudo do |nmap|
        3    nmap.syn_scan       = true
        4    nmap.os_fingerprint = true
        5    nmap.service_scan   = true
        6    nmap.output_xml     = 'scan.xml'
        7    nmap.verbose        = true
        8    nmap.ports   = [20, 21, 22, 23, 25, 80, 110, 443, 512, 522, 8080, 1080]
        9    nmap.targets = '10.6.6.*'
        10 end
        11 #Parse Nmap XML scan files:
        12 require 'nmap/xml'
        13 Nmap::XML.open('scan.xml') do |xml|
        14   xml.each_host do |host|
        15     puts "[#{host.ip}]"
        16     host.each_port do |port|
        17       puts "  #{port.number}/#{port.protocol}	#{port.state}	#{port.service}"
        18     end
        19   end
        20 end
    ```
+ Revise el ejemplo de código que se muestra. Utilice las características de sintaxis para determinar qué lenguaje de secuencias de comandos se utiliza para interpretar el código.<br>
    ```PowerShell
        1  $nmapExe = "Program Files (x86)Nmap
        map.exe"
        2  #define nmap targets
        3  $target = "10.6.6.0/24", "172.17.0.0/29"
        4  #run nmap scan for each target
        5  foreach ($target in $target)
        6  {
        7      $filename = "nmap_results"
        8      $nmapfile = ".	emp" + $filename + $target +".xml"
        9      cmd.exe /c "$nmapExe -p 20-25,80,443,3389,8080 -oX $nmapfile -A -v $target"
        10  }
    ```
